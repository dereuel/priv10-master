using Microsoft.Win32;
using MiscHelpers;
using System;
using System.Diagnostics.Eventing.Reader;
using System.Linq;
using System.Runtime.Serialization;
using System.Security.AccessControl;
using System.Security.Principal;

namespace WinFirewallAPI
{
    [Serializable()]
    [DataContract(Name = "FirewallEvent", Namespace = "http://schemas.datacontract.org/")]
    public class RuleChangedEvent : EventArgs
    {
        [DataMember()]
        public FirewallGuard.EventIDs EventID;

        [DataMember()]
        public string ProfileChanged;
        [DataMember()]
        public string RuleId;
        [DataMember()]
        public string RuleName;
    }

    public class FirewallGuard
    {
        /*
            {0CCE9232-69AE-11D9-BED3-505054503030}
            Identifies the MPSSVC Rule-Level Policy Change audit subcategory.
            This subcategory audits events generated by changes in policy rules used by Windows Firewall.
         */
        const string FirewallEventPolicyID = "0CCE9232-69AE-11D9-BED3-505054503030";

        public enum Mode : int
        {
            Alert = 0,
            Disable = 1,
            Fix = 2
        }

        public bool HasAuditPolicy()
        {
            try
            {
                AuditPolicy.AUDIT_POLICY_INFORMATION pol = AuditPolicy.GetSystemPolicy(FirewallEventPolicyID);
                if ((pol.AuditingInformation & AuditPolicy.AUDIT_POLICY_INFORMATION_TYPE.Success) != 0)
                    return true;
            }
            catch (Exception err)
            {
                AppLog.Exception(err);
            }
            return false;
        }

        public bool SetAuditPolicy(bool audit)
        {
            try
            {
                AuditPolicy.AUDIT_POLICY_INFORMATION pol = AuditPolicy.GetSystemPolicy(FirewallEventPolicyID);
                if (audit)
                    pol.AuditingInformation = AuditPolicy.AUDIT_POLICY_INFORMATION_TYPE.Success;
                else
                    pol.AuditingInformation = AuditPolicy.AUDIT_POLICY_INFORMATION_TYPE.None;
                TokenManipulator.AddPrivilege(TokenManipulator.SE_SECURITY_NAME);
                // Note: without SeSecurityPrivilege this fails silently
                AuditPolicy.SetSystemPolicy(pol);
                TokenManipulator.RemovePrivilege(TokenManipulator.SE_SECURITY_NAME);
            }
            catch (Exception err)
            {
                AppLog.Exception(err);
                return false;
            }
            return true;
        }

        EventLogWatcher mEventWatcher = null;

        public enum EventIDs
        {
            Added = 4946,
            Changed = 4947,
            Removed = 4948
        }

        protected string GetQuery()
        {
            return "*[System[EventID=" + (int)EventIDs.Added + " or EventID=" + (int)EventIDs.Changed + " or EventID=" + (int)EventIDs.Removed + "]]";
        }

        public bool StartEventWatcher()
        {
            try
            {
                mEventWatcher = new EventLogWatcher(new EventLogQuery("Security", PathType.LogName, GetQuery()));
                mEventWatcher.EventRecordWritten += new EventHandler<EventRecordWrittenEventArgs>(OnRuleChanged);
                mEventWatcher.Enabled = true;
            }
            catch (Exception err)
            {
                AppLog.Exception(err);
                return false;
            }
            return true;
        }

        public void StopEventWatcher()
        {
            if (mEventWatcher != null)
            {
                mEventWatcher.EventRecordWritten -= new EventHandler<EventRecordWrittenEventArgs>(OnRuleChanged);
                mEventWatcher.Dispose();
                mEventWatcher = null;
            }
        }

        private void OnRuleChanged(object obj, EventRecordWrittenEventArgs arg)
        {
            if (arg.EventRecord == null)
                return;

            RuleChangedEvent args = ReadFirewallEvent(arg.EventRecord);
            if (args != null)
                ChangeEvent?.Invoke(this, args);
        }


        enum EventProperties
        {
            PublisherName = 0,
            EventID,
            ProcessID,
            ThreadID,

            ProfileChanged,
            RuleId,
            RuleName
        };

        private EventLogPropertySelector eventPropertySelector = new EventLogPropertySelector(new[] {
            "Event/System/Provider/@Name",		            //  0
		    "Event/System/EventID",			                //  1
		    "Event/System/Execution/@ProcessID",            //  2
		    "Event/System/Execution/@ThreadID",             //  3

		    "Event/EventData/Data[@Name='ProfileChanged']",	//  4 - ProfileChanged
		    "Event/EventData/Data[@Name='RuleId']",	        //  5 - RuleId
		    "Event/EventData/Data[@Name='RuleName']",		//  6 - RuleName
        });

        protected RuleChangedEvent ReadFirewallEvent(EventRecord record)
        {
            try
            {
                var PropertyValues = ((EventLogRecord)record).GetPropertyValues(eventPropertySelector);

                RuleChangedEvent args = new RuleChangedEvent();

                //args.ProcessId = int.Parse(PropertyValues[(int)EventProperties.ProcessID].ToString()); // useless always lsass.exe pid

                args.EventID = (FirewallGuard.EventIDs)(UInt16)PropertyValues[(int)EventProperties.EventID];

                args.ProfileChanged = PropertyValues[(int)EventProperties.ProfileChanged].ToString();
                args.RuleId = PropertyValues[(int)EventProperties.RuleId].ToString();
                args.RuleName = PropertyValues[(int)EventProperties.RuleName].ToString();

                return args;
            }
            catch (Exception err)
            {
                AppLog.Exception(err);
            }
            return null;
        }

        public event EventHandler<RuleChangedEvent> ChangeEvent;


        /////////////////////////////////////////////////////////////
        // HardCore Protection

        public const string FirewallRulesKey  = @"SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\FirewallRules";

        public const string FirewallProfilesKey = @"SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles";

        public const string PrivateProfileKey = @"SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\StandardProfile";
        public const string DomainProfileKey  = @"SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\DomainProfile";
        public const string PublicProfileKey  = @"SYSTEM\CurrentControlSet\services\SharedAccess\Parameters\FirewallPolicy\PublicProfile";

        public const string FirewallServiceName = @"NT SERVICE\MpsSvc"; // Windows Defender Firewall

        public bool GetAccessRestriction(string keyPath)
        {
            try
            {
                RegistryKey subKey = Registry.LocalMachine.OpenSubKey(keyPath, false);
                RegistrySecurity keySec = subKey.GetAccessControl(AccessControlSections.Access);

                foreach (var rule in keySec.GetAccessRules(true, true, typeof(System.Security.Principal.NTAccount)).Cast<AuthorizationRule>())
                {
                    if (rule.IdentityReference.Value.Equals(FirewallServiceName, StringComparison.OrdinalIgnoreCase))
                        return true;
                }
            }
            catch (Exception err)
            {
                AppLog.Exception(err);
            }
            return false;
        }

        public bool SetAccessRestriction(string keyPath, bool bSet)
        {
            try
            {
                RegistryKey subKey = Registry.LocalMachine.OpenSubKey(keyPath, RegistryKeyPermissionCheck.ReadWriteSubTree, RegistryRights.ChangePermissions);
                RegistrySecurity keySec = subKey.GetAccessControl(AccessControlSections.Access);

                RegistryAccessRule systemRule = new RegistryAccessRule(new SecurityIdentifier(FileOps.SID_System), RegistryRights.FullControl, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);
                RegistryAccessRule serviceRule = new RegistryAccessRule(FirewallServiceName, RegistryRights.ExecuteKey, InheritanceFlags.ContainerInherit | InheritanceFlags.ObjectInherit, PropagationFlags.None, AccessControlType.Allow);
                if (bSet)
                {
                    keySec.SetAccessRuleProtection(true, false);
                    keySec.AddAccessRule(systemRule);
                    keySec.AddAccessRule(serviceRule);
                }
                else
                {
                    keySec.SetAccessRuleProtection(false, false);
                    keySec.RemoveAccessRule(systemRule);
                    keySec.RemoveAccessRule(serviceRule);
                }
                subKey.SetAccessControl(keySec);
                
                return true;
            }
            catch (Exception err)
            {
                AppLog.Exception(err);
            }
            return false;
        }
    }
}
